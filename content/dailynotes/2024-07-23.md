---
title: 2024-07-23
author: ["4shen0ne"]
draft: false
---

## Python @overload {#python-overload}

Python 中 `@overload` 注解可以用来描述一个方法/函数的重载，但是这里的重载和 Java 中
的重载概念不同，在 Python 中仅仅用于描述更具体的类型关系。

假设有以下函数：

```python
def double(input_: int | list[int]) -> int | list[int]:
    if isinstance(input_, list):
        return [i * 2 for i in input_]
    return input_ * 2
```

从实现我们可以看出函数的返回类型和参数类型是绑定的，不存在输入 int 返回 list 的
情况，但 python 的类型系统无法知道这一点，只能通过 type hint 判断返回类型为
`int | list` 。

这时候我们就可以使用 `@overload` 来描述更具体的类型关系：

```python
@overload
def double(input_: int) -> int:
    ...

@overload
def double(input_: list[int]) -> list[int]:
    ...

def double(input_: int | list[int]) -> int | list[int]:
    if isinstance(input_, list):
        return [i * 2 for i in input_]
    return input_ * 2
```

上述代码的前两个 double 函数的实现用 `...` 省略，只用于描述函数签名，这时候如果我
们传入的是 int 参数，python 就会知道返回的也是 int 类型。


## 从当前 buffer 读取文件名，批量删除文件 {#从当前-buffer-读取文件名-批量删除文件}

```elisp
(defun delete-files-from-current-buffer ()
  "Delete files listed in the current buffer.
Each line in the buffer should contain a relative file path."
  (interactive)
  (let ((current-buffer-file (buffer-file-name))
        (current-dir default-directory))
    (unless current-buffer-file
      (error "Current buffer is not visiting a file"))
    (save-excursion
      (goto-char (point-min))
      (while (not (eobp))
        (let* ((relative-file-path (buffer-substring-no-properties
                                    (line-beginning-position)
                                    (line-end-position)))
               (absolute-file-path (expand-file-name relative-file-path current-dir)))
          (when (file-exists-p absolute-file-path)
            (delete-file absolute-file-path)
            (message "Deleted file: %s" absolute-file-path)))
        (forward-line 1)))))
```
