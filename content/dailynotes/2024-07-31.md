---
title: 2024-07-31
author: ["4shen0ne"]
draft: false
---

## 尽可能使用 @dataclass {#尽可能使用-dataclass}

> You should never write def __init__(self, ...) -&gt; None: ever again. dataclasses
> allow you to define your instance variables once then a constructor is
> auto-generated and you can hook into them with def __post_init__(self) -&gt; None:
> but basically every python class should be a dataclass going forward with no
> exceptions (only exception maybe if you need to inherit from a non-dataclass,
> but even such cases can be worked around too where a dataclass inherits from a
> non-dataclass even if you have to annotate with @dataclass(unsafe_hash=True)
> (using said trick you can create dataclasses inheriting from nn.Module for a
> very clean system) or something else fun).

doc: <https://docs.python.org/zh-cn/3/library/dataclasses.html>


## python 中 dataclass 的属性默认值不能使用可修改的数据类型 {#python-中-dataclass-的属性默认值不能使用可修改的数据类型}

比如：

```python
@dataclass
class Foo:
    bar: list = []

# ValueError: mutable default <class 'list'> for field a is not allowed: use default_factory
```

原因：<https://stackoverflow.com/a/53633297>

简单来说就是 python 会将默认值保存在类属性中，如果类属性是列表，不同的实例在修改这
一属性的时候，实际上修改的是同一个列表，会导致异常逻辑

解决方法是使用 default_factory 让默认值在初始化实例时计算：

```python
from dataclasses import dataclass, field

@dataclass
class SomeClass:
    some_list: list = field(default_factory=lambda: ["your_values"])
```

如果希望所有实例共享这个属性，可以让 default_factory 返回一个全局变量：

```python
from dataclasses import dataclass, field

SHARED_LIST = ["your_values"]

@dataclass
class SomeClass:
    some_list: list = field(default_factory=lambda: SHARED_LIST)
```
